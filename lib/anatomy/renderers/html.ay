use("atomy")
use("io")

require("json")
require("fileutils")

use("anatomy/html")
data = require("anatomy/data")


tag-url(t) =
  t target match:
    .anchor(x) ->
      url(t part, x)

    .self ->
      url(t part)

    .url(x) ->
      x

over(i: data Itemization) :=
  <dl:
    [ <dt: over(name)
      <dd: over(body)
    ] for [name, body] in i elements
over(l: data List) :=
  <ul:
    <li{ over(body) } for body in l elements
over(l: data OrderedList) :=
  <ol:
    <li{ over(body) } for body in l elements
over(p: data Paragraph) :=
  <p: over(p content)
over(b: data Block) :=
  b style match:
    .tt ->
      <pre: over(b content)

    .verbatim ->
      <pre(.verbatim): over(b content)

    .class(*classes) ->
      <div(class = classes join(" ")): over(b content)

    .header(depth) ->
      <"h#{depth}": over(b content)

    nil ->
      <div: over(b content)

over(t: data Target) :=
  <a(name = t name): nil
over(p: data Reference) :=
  if(p tag)
    then:
      <a(href = tag-url(p tag)):
        over(p content)
    else:
      <a(.undefined): over(p content)
over(r: data ResolveElement) := error(.did-not-resolve(r))
over(e: data Element) :=
  e style match:
    .italic ->
      <em: over(e content)

    .bold ->
      <strong: over(e content)

    .tt ->
      <code: over(e content)

    .superscript ->
      <sup: over(e content)

    .subscript ->
      <sub: over(e content)

    -- TODO
    .smaller ->
      <span(style = "font-size: 80%"): over(e content)

    -- TODO
    .larger ->
      <span(style = "font-size: 120%"): over(e content)

    .strike ->
      <span(style = "text-decoration: line-through"): over(e content)

    .class(*classes) ->
      <span(class = classes join(" ")): over(e content)

    .hyperlink(url) ->
      <a(href = url): over(e content)

    .margin-note ->
      <blockquote: over(e content)

    .image(file) ->
      <img(src = file, alt = over(e content))

    .centered ->
      <div(style = "text-align: center"): over(e content)

over(nil) := nil
over(s: String) := s
over(a: Array) :=
  over(x) for x in a


filename(p) := p tag name + ".html"


top(p) :=
  condition:
    p parent and p parent toc? ->
      p

    p parent ->
      top(p parent)

    otherwise ->
      p

url(p, anchor = nil) :=
  condition:
    top(p) != p ->
      url(top(p)) + "#" + (anchor || p tag name)

    anchor ->
      filename(p) + "#" + anchor

    otherwise ->
      filename(p)


toc-leaf(part) :=
  <li:
    <a(href = url(part)):
      over(part title)

    unless(part omit-children-from-table-of-contents? or part parts empty?):
      <ol:
        toc-leaf(s) for s in part parts


render(part, out = ".") := do:
  tags = [t, d to-s, u] for [t, d, u] in search-tags(part)

  File open(i"#{out}/public/tags_#{part tag name}.js", "w") [f]:
    f write(i"var SEARCH_TAGS = #{tags to-json};")

  class =
    if(part style properties empty?)
      then: "normal"
      else: part style properties collect .to-s join(" ")

  File open(i"#{out}/#{filename(part)}", "w") [f]:
    f write("<!DOCTYPE html>")
    f write(
      <html {
        <head:
          <meta("http-equiv" = "Content-Type", content = "text/html; charset=UTF-8")
          <title: over(part title)
          <link(type = "text/css", rel = "stylesheet", href = "public/anatomy.css")
          <link(type = "text/css", rel = "stylesheet", href = "public/highlight.css")
          <script(type = "text/javascript", src = "public/jquery.js") {}
          <script(type = "text/javascript", src = "public/jquery.hotkeys.js") {}
          <script(type = "text/javascript", src = i"public/tags_#{part tag name}.js") {}
          <script(type = "text/javascript", src = "public/main.js") {}
        <body(class = class):
          <div(#main):
            <div(#content):
              render-part(part, out)

          <div(.search):
            <form(action = "javascript:void(0)"):
              <input(
                  type = "text"
                  placeholder = "Search&hellip;"
                  autocomplete = "off"
                  #search)

            <ul(.search-results) {}

          <div(#sidebar):
            unless(part parts empty?):
              [ <h4: "On this page:"

                <ol(.toc):
                  toc-leaf(s) for s in part parts
              ]

            when(part parent):
              [ <h4: "Up one level:"
                <ol(.toc):
                  toc-leaf(part parent)
              ]
      })

render-part(part, out = ".", depth = 1) := do:
  part assets each [a]:
    FileUtils cp(a, out)

  <div(.section, id = i"section_#{part tag name}"):
    <"h#{depth}"(.section_header):
      <a(name = part tag name) {}
      over(part title)

    over(part body)

    if(part toc?)
      then:
        <ol(.toc, #table-of-contents):
          part parts collect [sub]:
            render(sub, out)
            toc-leaf(sub)
      else:
        render-part(sub, out, depth + 1) for sub in part parts


search-tags(p) := do:
  tags = [
    [ data contents-of(p title)
      <span(.title):
        <a(href = url(p)):
          over(p title)
      url(p)
    ]
  ]

  p tags each-key [tag-name]:
    tag = p find-tag(tag-name)
    url = tag-url(tag)
    tags <<
      [ tag name
        tag display and over(tag display) or
          <span(.tag):
            <code:
              <a(href = url):
                tag name
        url
      ]

  p parts each [sub]:
    tags +=
      [ t
        if(d is-a(HTMLElement)? and d attributes[.class] == "with_parent")
          then: d
          else:
            <span(.with-parent):
              d
              <span(.parent):
                " in "
                <a(href = url(p)):
                  over(p title)
        u
      ] for [t, d, u] in search-tags(sub)

  tags
