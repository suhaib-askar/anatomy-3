use("atomy")
use("io")

require("json")

use("anatomy/html")
data = require("anatomy/data")


source-to-url(.anchor(part, anchor)) =
  url(part, anchor)
source-to-url(.part(part)) =
  url(part)
source-to-url(.url(url)) =
  url

over(s: String) := s
over(t: data::Target) :=
  <a(name = t tag): nil
over(p: data::Paragraph) :=
  <p: over(p content)
over(p: data::Reference) :=
  <a(href = source-to-url(p source)): over(p content)
over(a: Array) :=
  over(x) for x in a

filename(p) := p tag + ".html"

url(p, anchor = nil) :=
  condition:
    p parent ->
      url(p top) + "#" + (anchor || p tag)

    anchor ->
      filename(p) + "#" + anchor

    otherwise ->
      filename(p)


toc-leaf(part) :=
  <li:
    <a(href = url(part)):
      part title

    unless(part parts empty?):
      <ol:
        toc-leaf(s) for s in part parts


-- just return a string for now
render(part, out = ".") := do:
  with-output-to(i"#{out}/public/tags_#{part tag}.js"):
    tags = [t, d to-s, u] for [t, d, u] in search-tags(part)
    i"var SEARCH_TAGS = #{tags to-json};" println

  with-output-to(i"#{out}/#{filename(part)}"):
    "<!DOCTYPE html>" println
    <html {
      <head:
        <title: over(part title)
        <link(type = "text/css", rel = "stylesheet", href = "public/doodle.css")
        <script(type = "text/javascript", src = "public/jquery.js") {}
        <script(type = "text/javascript", src = "public/jquery.hotkeys.js") {}
        <script(type = "text/javascript", src = i"public/tags_#{part tag}.js") {}
        <script(type = "text/javascript", src = "public/main.js") {}
      <body:
        <div(#main):
          <div(#content):
            render-part(part)

        <div(.search):
          <form(action = "javascript:void(0)"):
            <input(
                type = "text"
                placeholder = "Search&hellip;"
                autocomplete = "off"
                #search)

          <ul(.search-results) {}

        <div(#sidebar):
          unless(part parts empty?):
            [ <h4: "On this page:"

              <ol(.toc):
                toc-leaf(s) for s in part parts
            ]

          when(part parent):
            [ <h4: "Up one level:"
              <ol(.toc):
                toc-leaf(part parent)
            ]
    } println

render-part(part, depth = 1) :=
  <div(.section, id = i"section_#{part tag}"):
    <"h#{depth}"(.section_header):
      <a(name = part tag) {}
      over(part title)

    over(part body)

    render-part(sub, depth + 1) for sub in part parts


search-tags(p) := do:
  tags = [
    [ p title
      <span(.title):
        <a(href = url(p)): p title
      url(p)
    ]
    [ p tag
      <span(.tag):
        "tag: "
        <code:
          <a(href = url(p)): p tag
      url(p)
    ]
  ]

  -- TODO: let tags control their display
  p tags each-key [tag]:
    url = source-to-url(p find-tag(tag))
    tags <<
      [ tag
        <span(.tag):
          <code:
            <a(href = url): tag
        url
      ]

  p parts each [sub]:
    tags +=
      [ t
        if(d attributes[.class] == "with_parent")
          then: d
          else:
            <span(.with-parent):
              d
              <span(.parent):
                " in "
                <a(href = url(p)): p title
        u
      ] for [t, d, u] in search-tags(sub)

  tags
