use("atomy")

data(Block(@content, @style = nil)):
  Table(@rows)
  Itemization(@elements)
  NestedFlow(@blocks)
  Paragraph(@content, @closed? = false)
  MetaBlock(@action)
  TraverseBlock(@action)
  ResolveBlock(@action)
  List(@elements):
    OrderedList(@elements)

data(Element(@content, @style = nil)):
  Target(@name)
  TOC(@content)
  Reference(@tag, @content = nil)
  Index(@keys, @description)
  TraverseElement(@action)
  ResolveElement(@action)
  CollectElement(@action)
  RenderElement(@action)

data(Style(@type = nil, @properties = []))

data(Tag(@part, @name, @target = .self, @display = nil))

data(
  Part(
    -- nil or title content
    @title = nil

    -- the part style
    -- TODO: can't do @style = Style new
    @style = nil

    -- initial content before sub-parts
    @body = []

    -- sub-parts
    @parts = []

    -- parent part
    @parent = nil

    -- tags
    -- tag -> reference
    @tags = #{}
    @tag-prefix = nil

    -- tags that cannot be found by parents
    @local-tags = #{}

    -- the primary tag used for this Part
    -- used for URIs
    @tag = nil

    -- content that is inspected during the collect pass,
    -- but doesn't produce output
    @to-collect = []))

-- TODO: can't declare with Style new default (see above)
Part style := @style ||= Style new

Part set-tag(name, target = .self, display = nil) :=
  @tags[name] = Tag new(self, name, target, display)

Part set-local-tag(name, target = nil, display = nil) :=
  @local-tags[name] = Tag new(self, name, target, display)

Part inspect := i"#<Part: '#{@tag name}'>"

-- search in order:
-- 1. local hidden tags
-- 2. local tags
-- 3. children
--   1. local tags
--   2. children
-- 4. parent
--   1. local hidden tags
--   2. tags
--   3. siblings, searching in order
--   4. parent ...
Part find-tag(tag, excluding = nil) :=
  catch(.found):
    search-tag-excluding(tag, nil)
    nil

Part search-tag-excluding(name, excluding) := do:
  found = @local-tags[name] || @tags[name]
  throw(.found, found) if found

  when(name == @title):
    throw(.found, @tag)

  @parts each [p]:
    unless(p == excluding):
      p search-tag(name)

  @parent search-tag-excluding(name, self) if @parent

  nil

-- called from find-tag; only search exposed tags and children
Part search-tag(name) := do:
  when(name == @title):
    throw(.found, @tag)

  when(found = @tags[name]):
    throw(.found, found)

  @parts each [p]:
    p search-tag(name)


Part top :=
  if(@parent)
    then: @parent top
    else: self

content(String)? := true
content(Element)? := true
content(nil)? := true
content(x: Array)? := x all? .content?
content(_)? := false

sanitize(x) :=
  contents-of(x) gsub(r" & ", " and ")
    gsub(r"\s+", "-")
    gsub(r"[^[:alnum:]_\-:.]", "")
    downcase

contents-of(s: String) := s
contents-of(e: Element) := contents-of(e content)
contents-of(b: Block) := contents-of(b content)
contents-of(a: Array) := (contents-of(x) for x in a) join
contents-of(nil) := ""
