use("atomy")
use("io")

require("stringio")

hl = require("hl")
token = require("hl/token")
atomy = hl load("atomy")

use("anatomy/html")
base = require("anatomy/base")
data = require("anatomy/data")


format-inline(tokens) = do:
  data::Element new(
    -- constants, identifiers, and operators
    if(t type tag is-in ["no", "n", "o"])
      then:
        data::ResolveElement new(
          [part]:
            tag = part find-tag(t contents)
            if(tag)
              then: data::Reference new(tag, t contents)
              else: t contents)
      else: t contents
    .class(t type tag)) for t in tokens

format-block(tokens) =
  data::Block new(
    data::Block new(
      format-inline(tokens)
      .tt)
    .class("highlight"))

interactive-line(input, line, context, bnd) = do:
  out = StringIO new
  err = StringIO new

  tokens =
    { with-restarts(use-tokens(ts) -> ts):
        with-output-to(out):
          with-error-to(err):
            atomy lex(
              Atomy::Compiler eval(
                input
                bnd
                context || "interaction"
                line) show)
    } bind:
      (e: Error) ->
        restart(
          .use-tokens
          [ token::Token new(
              token::Tagged new(.gr)
              i"#{e name}: #{e message}")
          ])

  [ format-inline(
      token::Token new(token::Tagged new(.caret), "> ") .
        atomy lex(input))
    "\n"
    out string
    unless(err string empty?):
      data::Element new(err string, .class("gr"))
    format-inline(tokens)
    "\n"
  ]


hl(x) := base code(format-inline(atomy new(x) run))
atomy(x) := format-block(atomy new(x) run)

environments = #{}
interaction(x, where = nil) := do:
  [mod, bnd] =
    if(where)
      then: environments[where] ||= Atomy make-wrapper-module
      else: Atomy make-wrapper-module

  mod use("atomy")

  before-mod = Atomy::CodeLoader module
  before-bnd = Atomy::CodeLoader context

  Atomy::CodeLoader module = mod
  Atomy::CodeLoader context = bnd

  { data::Block new(
      data::Block new(
        x split("\n") collect with-index [input, line]:
          interactive-line(input, line + 1, where, bnd)
        .tt)
      .class("interaction"))
  } ensuring:
    Atomy::CodeLoader module = before-mod
    Atomy::CodeLoader context = before-bnd

example(x) := do:
  data::Block new(
    [ data::Paragraph new([data::Element new("Example:", .italic)])
      interaction(x)
    ]
    .class("example"))

example-segment(x) :=
  data::Block new(
    [ data::Paragraph new([data::Element new("Example:", .italic)])
      format-block(atomy new(x) run)
    ]
    .class("example"))


def = require("define")
define(what, *arguments, return, body) := do:
  thumb = Atomy::Parser parse-node(what)

  message-name = def message-name(thumb) to-s
  tag-name =
    if(message-name =~ r"^[\p{Ll}_]")
      then: message-name tr("_", "-")
      else: message-name

  display = format-inline(atomy lex(what))
  data::Block new(
    [ base target-element(tag-name)
      data::Block new(
        [ data::Block new(
            [ display
              data::Element new(
                " => "
                .class("definition_result_arrow"))
              format-inline(atomy lex(return))
            ]
            .tt)
        ]
        .class("thumb"))
      body
    ]
    .class("definition"))

assign(name, to, body) := do:
  display = format-inline(atomy lex(name))
  data::Block new(
    [ base target-element(name, base code(display))
      data::Block new(
        [ data::Block new(
            [ display
              data::Element new(
                " = "
                .class("definition_result_arrow"))
              format-inline(atomy lex(to))
            ]
            .tt)
        ]
        .class("thumb"))
      body
    ]
    .class("definition"))
