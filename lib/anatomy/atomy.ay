use("atomy")
io = require("io")
pretty = require("pretty")

require("stringio")

hl = require("hl")
token = require("hl/token")
atomy = hl load("atomy")

use("anatomy/html")
base = require("anatomy/base")
data = require("anatomy/data")



format-inline(tokens, link-only = nil) =
  data Element new(
    -- constants, identifiers, and operators
    if(link-only and t contents is-in link-only or
        not link-only and t type tag is-in ["no", "n", "o"])
      then:
        data ResolveElement new(
          [part]:
            tag = part find-tag(t contents)
            if(tag)
              then: data Reference new(tag, t contents)
              else: t contents)
      else: t contents
    .class(t type tag)) for t in tokens

format-block(tokens, link-only = nil) =
  data Block new(
    base verbatim(format-inline(tokens, link-only))
    .class("highlight"))

-- redirect ALL stdout/stderr for interaction
with-all-output-to(out, err) &action = do:
  before-out = io OutputPort instance-variable-get(."@default")
  before-err = io ErrorPort instance-variable-get(."@default")

  { io OutputPort instance-variable-set(."@default", out)
    io ErrorPort instance-variable-set(."@default", err)

    io with-output-to(out):
      io with-error-to(err):
        action call
  } ensuring:
    io OutputPort instance-variable-set(."@default", before-out)
    io ErrorPort instance-variable-set(."@default", before-err)

interactive-line(mod, input, line, context) = do:
  out = StringIO new
  err = StringIO new

  output-tokens =
    { with-restarts(use-tokens(ts) -> ts):
        res =
          with-all-output-to(out, err):
            mod eval(input, line) tap:
              -- wait for output from spawned actors
              sleep(0.01)

        -- shorten the long-form inspections that show the ivars
        atomy lex(pretty show(res) sub(r"#<([^\s]+)\s+@.*$", "#<\\1>"))
    } bind:
      (e: Error) ->
        restart(
          .use-tokens
          [ token Token new(
              token Tagged new(.gr)
              i"#{e name}: #{e message}")
          ])

  [ format-inline(
      token Token new(token Tagged new(.caret), "> ") .
        atomy lex(input))
    "\n"
    out string
    unless(err string empty?):
      data Element new(err string, .class("gr"))
    format-inline(output-tokens)
    "\n"
  ]


hl(x) := base code(format-inline(atomy new(x) run))
atomy(x) := format-block(atomy new(x) run)

new-interaction-env(where = nil) =
  Atomy Module new(where || "interaction") tap [mod]:
    mod use("atomy")

environments = #{}
interaction(x, where = nil) := do:
  mod =
    if(where)
      then:
        environments[where] ||= new-interaction-env(where)
      else:
        new-interaction-env(where)

  data Block new(
    data Block new(
      x split("\n") collect with-index [input, line]:
        interactive-line(mod, input, line + 1, where)
      .tt)
    .class("interaction"))

example(x, where = nil) := do:
  data Block new(
    [ data Paragraph new([data Element new("Example:", .italic)])
      interaction(x, where)
    ]
    .class("example"))

example-segment(x) :=
  data Block new(
    [ data Paragraph new([data Element new("Example:", .italic)])
      format-block(atomy new(x) run)
    ]
    .class("example"))


def = require("define")
define(what, *rules, returns, body) := do:
  thumb = Atomy Parser parse-node(what)

  message-name = def message-name(thumb) to-s
  tag-name =
    if(message-name =~ r"^[\p{Ll}_]")
      then: message-name tr("_", "-")
      else: message-name

  display = format-inline(atomy lex(what), [tag-name])
  data Block new(
    [ base target-element(tag-name)
      data Block new(
        [ data Block new(
            [ display
              data Element new(
                " => "
                .class("definition_result_arrow"))
              format-inline(atomy lex(returns))
              ["\n  | ", format-inline(atomy lex(rule))] for rule in rules
            ]
            .tt)
        ]
        .class("thumb"))
      body
    ]
    .class("definition"))

assign(name, to, body) := do:
  display = format-inline(atomy lex(name), [name])
  data Block new(
    [ base target-element(name)
      data Block new(
        [ data Block new(
            [ display
              data Element new(
                " = "
                .class("definition_result_arrow"))
              format-inline(atomy lex(to))
            ]
            .tt)
        ]
        .class("thumb"))
      body
    ]
    .class("definition", "assign"))

find-tags(tags, c: Atomy AST Constant) = tags << c name to-s
find-tags(tags, `((~what)(~*_))) = find-tags(tags, what)
find-tags(tags, `(~what: ~*childs)) = do:
  find-tags(tags, what)
  find-tags(tags, c) for c in childs

data(tree, body) := do:
  tree-ast = Atomy Parser parse-node(tree)

  tag-names = []
  find-tags(tag-names, tree-ast)

  display = format-inline(atomy lex(tree), tag-names)
  data Block new(
    [ base target-element(name) for name in tag-names
      data Block new([base verbatim(display)], .class("thumb"))
      body
    ]
    .class("definition", "data"))

macro(pattern, *tag-names, result, body) := do:
  display = format-inline(atomy lex(pattern), tag-names)
  data Block new(
    [ base target-element(name) for name in tag-names
      data Block new([base verbatim(display)], .class("thumb"))
      body
    ]
    .class("definition", "macro"))
