use("atomy")
use("grammar")

parser(Parser):
  %%:
    trim-leading(str, n) := do:
      unless(n > 0):
        return(str)

      str gsub(r"\n {0,#{n}}", "\n")!

  %atomy := Atomy Parser

  line := { current-line }
  column := { current-column }

  comment := "{-" in-multi

  in-multi := [
    /"[^\-\{\}]*"/ "-}"
    /"[^\-\{\}]*"/ "{-" in-multi /"[^\-\{\}]*"/ "-}"
    /"[^\-\{\}]*"/ /"[-{}]"/ in-multi
  ]

  content(s) := comment? c=(chunk(s) | escaped) comment? { c }

  insignificant := (<(/"[^\\\{\}]+"/)> | "\\" <(/"[\\\{\}]"/)>) {
    text
  }

  chunk(s) := [
    l=(line) chunk=(insignificant+) c=((&"}" | comment)?) {
      text = chunk join

      when(c):
        text rstrip!

      trim-leading(text, s)

      text
    }

    nested
  ]

  escaped := [
    l=(line) "\\" n=(%atomy(identifier)) as=(argument+) {
      `((~(Atomy AST Word new(l, n)))(~*as))
    }

    l=(line) "\\" n=(%atomy(identifier)) {
      Atomy AST Word new(l, n)
    }

    l=(line) "\\" "(" e=(%atomy(expression)) ")" { e }
  ]

  leading := [
    &(/"\n+"/ b=(column) /"\s+"/ a=(column)) { a - b }
    { 0 }
  ]

  nested :=
    l=(line) "{" s=(leading) cs=(content(s)*) "}" {
      when(cs[0] is-a(String)?):
        cs[0] sub(r"^\n", "")!

      cs match:
        []: ""
        [x]: x
        _: cs
    }

  atomy := "[" e=(%atomy(expression)) "]" { e }

  argument := nested | atomy

  root :=
    l=(line) cs=(content(0)*) !_ {
      setup = Array[]
      definitions = Array[]

      filter = [c]:
        c match:
          (`use(~_) | `require(~_)):
            setup << c
            nil

          `(~x := ~y):
            definitions << `(~x := ~y)
            nil

          `define(~x, ~y):
            definitions << `(~x = ~y)

          Array: c map &filter

          _ -> c

      body = cs map &filter

      `(do:
          use("atomy")

          use("anatomy/base")

          ~*setup

          ~*definitions

          doc := decode(~*body))
    }


Parser singleton:
  parse-string(str) := do:
    p = new(str)
    unless(p parse):
      p raise-error

    p result

  parse-file(path) := do:
    File open(path, "r") [f]:
      parse-string(f read)
