use("atomy")

data = require("anatomy/data")
meta = require("anatomy/stages/meta")
traverse = require("anatomy/stages/traverse")
collect = require("anatomy/stages/collect")

hl = require("hl")

title(
    content
    -- TODO: can't do tag-name = data sanitize(content)
    tag-name = nil
    *extra-tag-names) :=
  data MetaBlock new(
    [part]:
      part title = content

      tag-name ||= data sanitize(content)

      part tag = part set-tag(tag-name, .self, content)

      extra-tag-names each [t]:
        part set-tag(t))

table-of-contents :=
  data MetaBlock new(
    [part]:
      part style properties << .toc)

section(title, *tag-names, content) :=
  decode(title(title, *tag-names), content)

include-section(path) :=
  Atomy load(path) doc

include-sections(path) := do:
  Dir glob(path) collect [s]:
    Atomy load(s) doc

target-element(tag-name, display = nil) :=
  data CollectElement new(
    [part]:
      part set-tag(tag-name, .anchor(tag-name), display)
      data Target new(tag-name))

verbatim(content) :=
  data Block new(content, .verbatim)

hyperlink(url, content) :=
  data Element new(content, .hyperlink(url))

reference(tag-name, content = nil) :=
  data ResolveElement new(
    [part]:
      tag = part find-tag(tag-name)
      unless(tag):
        warning(.undefined(tag-name))

      data Reference new(
        tag
        content or tag and tag display or tag-name))

definitions(content) := do:
  defs = []
  Array(content) select [x]:
    x match:
      .item(name, val) ->
        defs << [name, val]

  data Itemization new(defs)

item(name, content) := .item(name, content)

italic(content) := data Element new(content, .italic)

list(*elements) := data List new(elements)

ordered-list(*elements) := data OrderedList new(elements)

bold(content) := data Element new(content, .bold)

smaller(content) := data Element new(content, .smaller)

larger(content) := data Element new(content, .larger)

superscript(content) := data Element new(content, .superscript)

subscript(content) := data Element new(content, .subscript)

code(content) := data Element new(content, .tt)

margin-note(content) := data Element new(content, .margin-note)

aux(content) := content -- todo

format-inline(tokens, link-only = nil) =
  data Element new(
    -- constants, identifiers, and operators
    if(link-only and t contents is-in link-only or
        not link-only and t type tag is-in ["no", "n", "o"])
      then:
        data ResolveElement new(
          [part]:
            tag = part find-tag(t contents)
            if(tag)
              then: data Reference new(tag, t contents)
              else: t contents)
      else: t contents
    .class(t type tag)) for t in tokens

format-block(tokens, link-only = nil) =
  data Block new(
    verbatim(format-inline(tokens, link-only))
    .class("highlight"))

codeblock(language, content) :=
  { format-block(hl load(language) new(content) run) } rescue:
    LoadError:
      warning(.unknown-language(language))
      verbatim(content)

newline := data Element new("", .newline)

no-break(content) := data Element new(content, .no-break)

decode(*cs) := do:
  part = data Part new

  meta over(cs, part)

  part
