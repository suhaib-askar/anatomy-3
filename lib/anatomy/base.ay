use("atomy")

data = require("anatomy/data")
meta = require("anatomy/stages/meta")
traverse = require("anatomy/stages/traverse")
collect = require("anatomy/stages/collect")


title(
    content
    -- TODO: can't do tag = data sanitize(content)
    tag = nil
    *extra-tags) :=
  data::MetaBlock new(
    [part]:
      part title = content

      tag ||= data sanitize(content)
      part tag = tag
      part tags[tag] = .self

      extra-tags each [t]:
        part tags[t] = .self)

table-of-contents :=
  data::MetaBlock new(
    [part]:
      part style properties << .toc)

section(title, content) :=
  decode(title(title), content)

include-section(path) :=
  Atomy load(path) doc

target-element(tag) :=
  data::CollectElement new(
    [part]:
      part tags[tag] = .anchor(tag)
      data::Target new(tag))

verbatim(content) :=
  data::Block new(content, .tt)

reference(tag, content = nil) :=
  data::ResolveElement new(
    [part]:
      target = part find-tag(tag)
      unless(target):
        warning(.undefined(tag))

      -- TODO: fallback onto tag's display
      content ||= tag

      data::Reference new(target, content))

definitions(content) := do:
  defs = []
  Array(content) select [x]:
    x match:
      .item(name, val) ->
        defs << [name, val]

  data::Itemization new(defs)

item(name, content) := .item(name, content)

italic(content) := data::Element new(content, .italic)

bold(content) := data::Element new(content, .bold)

smaller(content) := data::Element new(content, .smaller)

larger(content) := data::Element new(content, .larger)

superscript(content) := data::Element new(content, .superscript)

subscript(content) := data::Element new(content, .subscript)

code(content) := data::Element new(content, .tt)

newline := data::Element new("", .newline)

no-break(content) := data::Element new(content, .no-break)

decode(*cs) := do:
  part = data::Part new

  meta over(cs, part)

  part
